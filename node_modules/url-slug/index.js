"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var unidecode = require('unidecode');
/* TODO v2.2
 * - Remove support for transformers represented by strings ('uppercase', etc.)
 */

/* TODO v3
 * - ESM with multiple exports
 * - Deprecate defaultTransformers
 * - Deprecate parseOptions, use a config object instead
 * - Add support to NFKD normalize, make unidecode an option (full?)
 * - Browser support
 * - Add sentence case transformer
 * - Supported characters:
 *   - default: ALPHA / DIGIT / "-" / "." / "_" / "~"
 *   - path: ALPHA / DIGIT / "-" / "." / "_" / "~" / "!" / "$" / "&" /
 *           "'" / "(" / ")" / "*" / "+" / "," / ";" / "=" / "@"
 *     - ":" is non-zero-length segment without any colon, allow it?
 *   - query: ALPHA / DIGIT / "-" / "." / "_" / "~" / "!" / "$" / "'" / "(" /
 *            ")" / "*" / "+" / "," / ";" / "=" / "@" / "/" / "?"
 *     - "&" is commonly used to separate key/value pairs, allow it?
 *   - hash: ALPHA / DIGIT / "-" / "." / "_" / "~" / "!" / "$" / "&" / "'" /
 *           "(" / ")" / "*" / "+" / "," / ";" / "=" / "@" / "/" / "?"
 */


var INVALID_SEPARATOR = /[^-._~]/;
var NORMALIZE = /[A-Za-z0-9]*?[a-z](?=[A-Z])|[A-Za-z0-9]+/g;
var REVERT_CAMELCASE = /.*?[a-z](?=[A-Z])|.+/g;
var REVERT_UNKNOWN = /[^-._~]*?[a-z](?=[A-Z])|[^-._~]+/g;
/**
* Check and return validated options
*/

function parseOptions(options) {
  var separator;
  var transformer;

  if (2 === options.length) {
    var _options = _slicedToArray(options, 2);

    separator = _options[0];
    transformer = _options[1];

    if (defaultTransformers[transformer]) {
      transformer = defaultTransformers[transformer];
      /* Don't validate */

      validate({
        separator
      });
    } else {
      validate({
        separator,
        transformer
      });
    }
  } else if (1 === options.length) {
    var option = options[0];

    if (false === option || 'function' === typeof option) {
      transformer = option;
      /* Don't validate */
    } else if (defaultTransformers[option]) {
      transformer = defaultTransformers[option];
      /* Don't validate */
    } else {
      separator = option;
      validate({
        separator
      });
    }
  }

  return {
    separator,
    transformer
  };
}
/**
* Validate options
*/


function validate(_ref) {
  var separator = _ref.separator,
      transformer = _ref.transformer;

  /* separator */
  if (null != separator) {
    if ('string' !== typeof separator) {
      throw new Error(`The separator must be a string: "${separator}".`);
    } else if (INVALID_SEPARATOR.test(separator)) {
      throw new Error(`The separator has invalid characters: "${separator}".`);
    }
  }
  /* transformer */


  if (null != transformer) {
    if (false !== transformer && 'function' !== typeof transformer && !defaultTransformers[transformer]
    /* TODO Deprecate */
    ) {
        throw new Error(`The transformer must be a function: "${transformer}".`);
      }
  }
}

var UrlSlug =
/*#__PURE__*/
function () {
  _createClass(UrlSlug, null, [{
    key: "LOWERCASE_TRANSFORMER",
    value: function LOWERCASE_TRANSFORMER(fragments, separator) {
      return fragments.join(separator).toLowerCase();
    }
  }, {
    key: "UPPERCASE_TRANSFORMER",
    value: function UPPERCASE_TRANSFORMER(fragments, separator) {
      return fragments.join(separator).toUpperCase();
    }
  }, {
    key: "TITLECASE_TRANSFORMER",
    value: function TITLECASE_TRANSFORMER(fragments, separator) {
      return fragments.map(function (fragment) {
        return fragment.charAt(0).toUpperCase() + fragment.slice(1).toLowerCase();
      }).join(separator);
    }
    /**
    * Creates a new instance of url-slug
    */

  }]);

  function UrlSlug() {
    var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '-';
    var transformer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UrlSlug.LOWERCASE_TRANSFORMER;

    _classCallCheck(this, UrlSlug);

    var options = parseOptions([separator, transformer]);
    this.separator = options.separator;
    this.transformer = options.transformer;
  }
  /**
  * Converts a string into a slug
  */


  _createClass(UrlSlug, [{
    key: "convert",
    value: function convert(string) {
      for (var _len = arguments.length, options = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        options[_key - 1] = arguments[_key];
      }

      var _parseOptions = parseOptions(options),
          _parseOptions$separat = _parseOptions.separator,
          separator = _parseOptions$separat === void 0 ? this.separator : _parseOptions$separat,
          _parseOptions$transfo = _parseOptions.transformer,
          transformer = _parseOptions$transfo === void 0 ? this.transformer : _parseOptions$transfo;

      var fragments = unidecode(String(string)).match(NORMALIZE);

      if (!fragments) {
        return '';
      }

      return transformer ? transformer(fragments, separator) : fragments.join(separator);
    }
    /**
    * Reverts a slug back to a string
    */

  }, {
    key: "revert",
    value: function revert(slug) {
      for (var _len2 = arguments.length, options = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        options[_key2 - 1] = arguments[_key2];
      }

      var _parseOptions2 = parseOptions(options),
          _parseOptions2$separa = _parseOptions2.separator,
          separator = _parseOptions2$separa === void 0 ? null : _parseOptions2$separa,
          _parseOptions2$transf = _parseOptions2.transformer,
          transformer = _parseOptions2$transf === void 0 ? false : _parseOptions2$transf;

      var fragments;
      slug = String(slug);
      /* Determine which method will be used split the slug */

      if ('' === separator) {
        fragments = slug.match(REVERT_CAMELCASE);
      } else if ('string' === typeof separator) {
        fragments = slug.split(separator);
      } else {
        fragments = slug.match(REVERT_UNKNOWN);
      }

      if (!fragments) {
        return '';
      }

      return transformer ? transformer(fragments, ' ') : fragments.join(' ');
    }
  }]);

  return UrlSlug;
}();
/**
* Builtin transformers // TODO Deprecate
*/


var defaultTransformers = {
  lowercase: UrlSlug.LOWERCASE_TRANSFORMER,
  uppercase: UrlSlug.UPPERCASE_TRANSFORMER,
  titlecase: UrlSlug.TITLECASE_TRANSFORMER
  /* Prepare the global instance and export it */

};
var urlSlug = new UrlSlug();
var global = urlSlug.convert.bind(urlSlug);
global.UrlSlug = UrlSlug;
global.convert = global;
global.revert = urlSlug.revert.bind(urlSlug);
global.transformers = defaultTransformers; // TODO Deprecate

module.exports = global;